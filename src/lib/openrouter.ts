export type LlmCardInput = {
  original_name: string;
  type_line: string;
  mana_cost: string;
  rules_text: string;
  is_legendary: boolean;
  is_commander: boolean;
  color_identity: string[];
  token_hints?: Array<{ name: string; type_line: string }>;
  user_note?: string;
};

export type LlmCardOutput = {
  original_name: string;
  thematic_name: string;
  mana_cost: string;
  type_line: string;
  rules_text: string;
  thematic_flavor_text: string;
  media_reference: string; // include artist credit
  midjourney_prompt: string; // must include --ar 3:5 and either --v 6 or --v 7
};

export type LlmBatchResponse = {
  cards: LlmCardOutput[];
};

function buildBatchPrompt(theme: string, cards: LlmCardInput[], deckIdea?: string): string {
  const header = `You are designing themed proxy cards for Magic: The Gathering. Theme: "${theme}".
${deckIdea ? `\nAdditional thematic guidance (apply across all cards):\n${deckIdea}\n` : ""}
Follow strict rules:
- Never reuse or partially reuse the original Magic card name. The "thematic_name" must be fully thematic to the chosen franchise and must not contain the original name.
- For Legendary cards, ALWAYS use NAME, ROLE syntax (e.g., "Kenrith, Returned King"). Both NAME and ROLE must be thematic, unique, and concise.
- Strongly align the proxy to the original rules text and card type. Creatures→characters, Artifacts→objects, Spells→actions/events; Lands/Enchantments flexible.
- Include tokens generated by cards; the token concept must fit cohesively with its source card in the theme.
- Return ONLY valid JSON matching the schema. Do not include commentary.
- For each card output fields: original_name, thematic_name, mana_cost, type_line, rules_text, thematic_flavor_text, media_reference, midjourney_prompt.
- midjourney_prompt must end with "--ar 3:5" and either "--v 6" or "--v 7".
- Media references must be specific and accurate. Prefer comics/illustration sources when suitable. Include the work title and the artist/creator credit (e.g., "Darth Vader by Adi Granov, Marvel Comics, 2015"). Do not invent credits; if uncertain, choose a canonical, well-attributed reference.
- Generate exactly one concept per card.
`;
  const schema = `JSON Schema (conceptual):
{
  "cards": [
    {
      "original_name": "string",
      "thematic_name": "string",
      "mana_cost": "string",
      "type_line": "string",
      "rules_text": "string",
      "thematic_flavor_text": "string",
      "media_reference": "string",
      "midjourney_prompt": "string"
    }
  ]
}`;
  const items = cards
    .map((c) => {
      const note = c.user_note ? `\nuser_note: ${c.user_note}` : "";
      const tokens = c.token_hints && c.token_hints.length
        ? `\ntoken_hints: ${c.token_hints.map((t) => `${t.name} (${t.type_line})`).join(", ")}`
        : "";
      return `- original_name: ${c.original_name}\n  type_line: ${c.type_line}\n  mana_cost: ${c.mana_cost}\n  rules_text: ${c.rules_text}\n  is_legendary: ${c.is_legendary}\n  is_commander: ${c.is_commander}\n  color_identity: [${c.color_identity.join(", ")}]${tokens}${note}`;
    })
    .join("\n");
  const instruction = `Return JSON ONLY for the following ${cards.length} cards in a single object: { "cards": [...] }`;
  return [header, schema, instruction, items].join("\n\n");
}

export async function callOpenRouterBatch(theme: string, cards: LlmCardInput[], deckIdea?: string): Promise<LlmBatchResponse> {
  const apiKey = process.env.OPENROUTER_API_KEY;
  const baseUrl = process.env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1";
  const model = process.env.OPENROUTER_MODEL || "openai/gpt-5-mini";
  if (!apiKey) throw new Error("OPENROUTER_API_KEY not set");

  const prompt = buildBatchPrompt(theme, cards, deckIdea);

  const resp = await fetch(`${baseUrl}/chat/completions`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model,
      messages: [
        { role: "system", content: "You are a careful JSON generator that strictly follows schemas." },
        { role: "user", content: prompt },
      ],
      temperature: 0.8,
      response_format: { type: "json_object" },
    }),
  });

  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`OpenRouter error ${resp.status}: ${text}`);
  }
  const data = await resp.json();
  const content = data.choices?.[0]?.message?.content ?? "{}";
  const parsed = JSON.parse(content) as LlmBatchResponse;
  if (!parsed.cards || !Array.isArray(parsed.cards)) {
    throw new Error("LLM response missing cards array");
  }
  // Ensure midjourney constraints
  parsed.cards = parsed.cards.map((c) => ({
    ...c,
    midjourney_prompt: ensureMjParams(c.midjourney_prompt),
  }));
  return parsed;
}

function ensureMjParams(prompt: string): string {
  const hasAr = /--ar\s*3:5/.test(prompt);
  const hasV6 = /--v\s*6/.test(prompt);
  const hasV7 = /--v\s*7/.test(prompt);
  let out = prompt.trim();
  if (!hasAr) out += " --ar 3:5";
  if (!hasV6 && !hasV7) out += " --v 6"; // default to v6
  return out;
}

// named export already declared above
