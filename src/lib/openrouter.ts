export type LlmCardInput = {
  original_name: string;
  type_line: string;
  mana_cost: string;
  rules_text: string;
  is_legendary: boolean;
  is_commander: boolean;
  color_identity: string[];
  token_hints?: Array<{ name: string; type_line: string; rulesText: string }>;
  user_note?: string;
  is_double_faced?: boolean;
  card_faces?: Array<{
    name: string;
    typeLine: string;
    rulesText: string;
    manaCost: string;
  }>;
  produces_tokens?: boolean;
  token_types?: Array<{ name: string; rulesText: string; typeLine: string }>;
};

export type LlmCardOutput = {
  original_name: string;
  thematic_name: string;
  mana_cost: string;
  type_line: string;
  rules_text: string;
  thematic_flavor_text: string;
  media_reference: string; // include artist credit
  midjourney_prompt: string; // must include --ar 3:5 and either --v 6 or --v 7
  card_faces?: Array<{
    thematic_name: string;
    thematic_flavor_text: string;
    media_reference: string;
    midjourney_prompt: string;
  }>;
  tokens?: Array<{
    thematic_name: string;
    thematic_flavor_text: string;
    media_reference: string;
    midjourney_prompt: string;
  }>;
};

export type LlmBatchResponse = {
  cards: LlmCardOutput[];
};

function buildBatchPrompt(theme: string, cards: LlmCardInput[], deckIdea?: string): string {
  const header = `You are designing themed proxy cards for Magic: The Gathering. Theme: "${theme}".
${deckIdea ? `\nAdditional thematic guidance (apply across all cards):\n${deckIdea}\n` : ""}
Follow strict rules:
- Never reuse or partially reuse the original Magic card name. The "thematic_name" must be fully thematic to the chosen franchise and must not contain the original name.
- For Legendary cards, ALWAYS use NAME, ROLE syntax (e.g., "Kenrith, Returned King"). Both NAME and ROLE must be thematic, unique, and concise.
- Strongly align the proxy to the original rules text and card type. Creatures→characters, Artifacts→objects, Spells→actions/events; Lands/Enchantments flexible.
- Include tokens generated by cards; the token concept must fit cohesively with its source card in the theme.
- For double-faced cards (DFC), generate separate thematic content for each face: unique names, flavor text, media references, and Midjourney prompts.
- Return ONLY valid JSON matching the schema. Do not include commentary.
- For each card output fields: original_name, thematic_name, mana_cost, type_line, rules_text, thematic_flavor_text, media_reference, midjourney_prompt.
- For DFC cards, include card_faces array with separate thematic content for each face.
- For token-producing cards, include tokens array with thematic content for each token type. Each token must have unique thematic names, flavor text, media references, and Midjourney prompts. IMPORTANT: Do NOT generate tokens for "Copy" token types or tokens that are just copies of the original card (like Scute Swarm copies) - only generate for actual creature/object tokens. Each token should have a thematic name that reflects its mechanical abilities (e.g., a flying token might be called "Sky Sentinel" or "Winged Guardian").
- Example: For a card that creates "1/1 white Soldier token" and "4/4 white Angel token with flying and vigilance", create tokens with names like "Imperial Trooper" (for the Soldier) and "Vigilant Sky Marshal" (for the Angel), and describe their visual appearance rather than listing "1/1" or "4/4" stats.
- When generating token proxies, pay special attention to the token's rules text (abilities like flying, vigilance, etc.) and incorporate these mechanical properties into the thematic concept and Midjourney prompt.
- IMPORTANT: Midjourney prompts should focus on visual description and avoid mechanical game terms. Instead of "4/4 Angel token with flying and vigilance", describe the visual appearance: "A majestic winged warrior with gleaming armor, hovering gracefully above the battlefield with an alert, watchful stance". The prompt should paint a picture, not list game mechanics.
- For token abilities, translate them into visual descriptions:
  * Flying → "soaring above", "hovering", "winged", "aerial"
  * Vigilance → "alert stance", "watchful", "vigilant", "ready position"
  * First strike → "quick reflexes", "swift", "precise"
  * Haste → "energetic", "dynamic", "burst of speed"
  * Deathtouch → "deadly", "venomous", "lethal", "dangerous"
  * Lifelink → "radiant", "glowing", "vital", "life-giving"
- midjourney_prompt must end with "--ar 3:5" and either "--v 6" or "--v 7".
- Media references must be specific and accurate. Prefer comics/illustration sources when suitable. Include the work title and the artist/creator credit (e.g., "Darth Vader by Adi Granov, Marvel Comics, 2015"). Do not invent credits; if uncertain, choose a canonical, well-attributed reference.
- Generate exactly one concept per card.
- IMPORTANT: When a card produces tokens, you MUST generate the tokens array with complete thematic content for each token type. However, if the card only produces copy tokens (like Scute Swarm), leave the tokens array empty or omit it entirely. For meaningful tokens, ensure the thematic concept reflects their mechanical abilities through visual description rather than game terms.
- REMEMBER: Midjourney prompts are for image generation, not game mechanics. Focus on what the viewer would see: colors, poses, equipment, environment, mood, and visual style. Avoid numbers, stats, or game terminology.
`;
  const schema = `JSON Schema (conceptual):
{
  "cards": [
    {
      "original_name": "string",
      "thematic_name": "string",
      "mana_cost": "string",
      "type_line": "string",
      "rules_text": "string",
      "thematic_flavor_text": "string",
      "media_reference": "string",
      "midjourney_prompt": "string",
      "card_faces": [
        {
          "thematic_name": "string",
          "thematic_flavor_text": "string",
          "media_reference": "string",
          "midjourney_prompt": "string"
        }
      ],
      "tokens": [
        {
          "thematic_name": "string",
          "thematic_flavor_text": "string",
          "media_reference": "string",
          "midjourney_prompt": "string"
        }
      ]
    }
  ]
}`;
  const items = cards
    .map((c) => {
      const note = c.user_note ? `\nuser_note: ${c.user_note}` : "";
      const tokens = c.token_hints && c.token_hints.length
        ? `\ntoken_hints: ${c.token_hints.map((t) => `${t.name} (${t.type_line})${t.rulesText ? ` - ${t.rulesText}` : ''}`).join(", ")}`
        : "";
      const dfc = c.is_double_faced ? `\n  is_double_faced: true\n  card_faces: ${c.card_faces?.map(f => `${f.name} (${f.typeLine})`).join(", ")}` : "";
      const tokenProd = c.produces_tokens ? `\n  produces_tokens: true\n  token_types: ${c.token_types?.map(t => `${t.name} (${t.typeLine})${t.rulesText ? ` - ${t.rulesText}` : ''}`).join(", ")}` : "";
      return `- original_name: ${c.original_name}\n  type_line: ${c.type_line}\n  mana_cost: ${c.mana_cost}\n  rules_text: ${c.rules_text}\n  is_legendary: ${c.is_legendary}\n  is_commander: ${c.is_commander}\n  color_identity: [${c.color_identity.join(", ")}]${tokens}${dfc}${tokenProd}${note}`;
    })
    .join("\n");
  const instruction = `Return JSON ONLY for the following ${cards.length} cards in a single object: { "cards": [...] }`;
  return [header, schema, instruction, items].join("\n\n");
}

export async function callOpenRouterBatch(theme: string, cards: LlmCardInput[], deckIdea?: string): Promise<LlmBatchResponse> {
  const apiKey = process.env.OPENROUTER_API_KEY;
  const baseUrl = process.env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1";
  const model = process.env.OPENROUTER_MODEL || "openai/gpt-5-mini";
  if (!apiKey) throw new Error("OPENROUTER_API_KEY not set");

  const prompt = buildBatchPrompt(theme, cards, deckIdea);

  const resp = await fetch(`${baseUrl}/chat/completions`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model,
      messages: [
        { role: "system", content: "You are a careful JSON generator that strictly follows schemas." },
        { role: "user", content: prompt },
      ],
      temperature: 0.8,
      response_format: { type: "json_object" },
    }),
  });

  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`OpenRouter error ${resp.status}: ${text}`);
  }
  const data = await resp.json();
  const content = data.choices?.[0]?.message?.content ?? "{}";
  const parsed = JSON.parse(content) as LlmBatchResponse;
  if (!parsed.cards || !Array.isArray(parsed.cards)) {
    throw new Error("LLM response missing cards array");
  }
  // Ensure midjourney constraints
  parsed.cards = parsed.cards.map((c) => ({
    ...c,
    midjourney_prompt: ensureMjParams(c.midjourney_prompt),
  }));
  return parsed;
}

function ensureMjParams(prompt: string): string {
  const hasAr = /--ar\s*3:5/.test(prompt);
  const hasV6 = /--v\s*6/.test(prompt);
  const hasV7 = /--v\s*7/.test(prompt);
  let out = prompt.trim();
  if (!hasAr) out += " --ar 3:5";
  if (!hasV6 && !hasV7) out += " --v 6"; // default to v6
  return out;
}

// named export already declared above
